#' Parse Recorder Activity From Log Files
#'
#' Reads log files created by acoustic monitors and determines their status
#' throughout a specified monitoring period. This information is essential for
#' interpreting patterns of bat activity because it effectively amounts to the
#' sampling effort. In other words, did you record no bats that night because
#' there were no bats, or because the monitor had run out of batteries...
#'
#' @section Note: this function is currently only capable of parsing log files
#'   generated by either Wildlife Acoustics SM3 or SM4 or Titley Anabat Swift
#'   bat recorders.
#'
#' @section Note: To work as expected, log files must be renamed following the
#'   conventions outlined below!
#'
#'   \strong{Wildlife Acoustics:} These files should be renamed so that each
#'   file name begins with the site name followed by a hyphen and any additional
#'   information (e.g. date) that is desired in the file name. For example:
#'   "site_1-2019.txt". The hyphen and all characters that follow it will be
#'   disregarded. The site name should match the site name assigned in GUANO
#'   metadata so that the log file data is appropriately matched with the
#'   acoustic data.
#'
#'   \strong{Anabat Swift:} These files do not need to be renamed, but files for
#'   each site should be placed in their own sub-folder. The folder name should
#'   match the site name assigned in the GUANO metadata of the corresponding WAV
#'   files so they can be matched.
#'
#' @param log_path Character. Path to directory containing log files generated
#'   by a Wildlife Acoustics SM3 or SM4 or Titley Anabat Swift bat recorder,
#'   organised as outlined above.
#' @param data_path Character. Path to an RData file to add activity data to.
#'   Optional, a save location will be created before data are saved.
#' @param monitoring_start Character. A date in the format "YYYY-MM-DD".
#'   Optional: use to specify a monitoring start date prior to the earliest date
#'   for which a log file exists.
#' @param monitoring_end Character. A date in the format "YYYY-MM-DD". Optional:
#'   use to specify a monitoring end date prior to the earliest date for which a
#'   log file exists.
#'
#' @return An RData file containing a data.frame of recorder activity.
#' @export
#'
#' @family import tools
#'
#' @examples \dontrun{
#' #' import_logs("C:/Folder/Folder/logss_Folder", "C:/Folder/Folder/Data.RData", "2021-01-01", "2021-12-31)
#' }
#'
import_logs <- function(log_path, data_path = NULL, monitoring_start = NULL, monitoring_end = NULL) {
  data_path <- .check_data_path(data_path)
  wa_file_list <- list.files(log_path,
    recursive = TRUE,
    pattern = "*.txt",
    full.names = TRUE
  )
  swift_file_list <- list.files(log_path,
    recursive = TRUE,
    pattern = "log \\d{4}-\\d{2}-\\d{2}\\.csv",
    full.names = TRUE
  )
  ranger_file_list <- list.files(log_path,
    recursive = TRUE,
    pattern = "ranger",
    full.names = TRUE
  )
  wa_active_dates <- NULL
  swift_active_dates <- NULL
  ranger_active_dates <- NULL
  if (length(wa_file_list) > 0) {
    wa_active_dates <- batr:::.read_wa_logs(
      wa_file_list,
      log_path,
      monitoring_start,
      monitoring_end,
      data_path
    )
  }
  if (length(swift_file_list) > 0) {
    swift_active_dates <- batr:::.read_swift_logs(
      swift_file_list,
      log_path,
      monitoring_start,
      monitoring_end,
      data_path
    )
  }
  if (length(ranger_file_list) > 0) {
    ranger_active_dates <- batr:::.read_ranger_logs(
      ranger_file_list,
      log_path,
      monitoring_start,
      monitoring_end
    )
  }
  active_dates <- do.call(rbind, Filter(Negate(is.null), list(
    wa_active_dates,
    swift_active_dates,
    ranger_active_dates
  )))
  .save_to_RDATA(active_dates, data_path)
}

.read_wa_logs <- function(wa_file_list, log_path, monitoring_start, monitoring_end, data_path) {
  message("Wildlife Acoustics summary files found. Reading files:")
  output <- data.table::rbindlist(
    sapply(wa_file_list,
      data.table::fread,
      simplify = FALSE,
      select = c("DATE", "TIME")
    ),
    use.names = TRUE, idcol = "FileName", fill = TRUE
  )
  # Remove rows that don't match the regular date expression
  output <- output[grepl("^\\d{4}-[a-zA-Z]{3}-\\d{2}$", output$DATE), ]
  output$DATE <- lubridate::ymd(output$DATE)
  output$Time <- as.POSIXct(output$TIME, format = "%H:%M:%S")
  output <- within(output, {
    night <- ifelse(lubridate::hour(output$Time) > 11,
      output$DATE,
      output$DATE - 1
    )
  })
  output$night <- as.Date(output$night)
  output$Location <- sapply(strsplit(
    sapply(strsplit(output$FileName, split = "/"), tail, n = 1),
    "-"
  ), `[`, 1)
  output$Location <- gsub("_", " ", output$Location)
  wa_active_dates <- as.data.frame(table(output$night, output$Location))
  colnames(wa_active_dates) <- c("Date", "Location", "Log_Count")
  wa_active_dates$Date <- lubridate::ymd(wa_active_dates$Date)
  return(wa_active_dates)
}

.read_swift_logs <- function(swift_file_list, log_path, monitoring_start, monitoring_end, data_path) {
  message("Anabat Swift log files found. Reading files:")
  output <- as.data.frame(swift_file_list)
  output$Date <- strptime(gsub(".*/", "", output$swift_file_list), "log %Y-%m-%d")
  output$Location <- sapply(strsplit(output$swift_file_list, "/"), function(x) x[length(x) - 1])
  output$Log_Count <- NA
  output$Active <- NA
  row_iterator <- 1
  for (file in output$swift_file_list) {
    file_data <- read.csv(file)
    mic_fails <- length(grep("Status: Check microphone", file_data[, 3]))
    files <- length(grep("FILE", file_data[, 2]))
    recording <- any(grepl("Status: Recording now", file_data[, 3]))
    if (mic_fails > 1 && files < 10) {
      output[row_iterator, 5] <- "N"
    } else if (mic_fails > 1 || isFALSE(recording)) {
      output[row_iterator, 5] <- "N"
    } else {
      output[row_iterator, 5] <- "Y"
    }
    row_iterator <- row_iterator + 1
  }
  output$Date <- as.Date(output$Date)
  output[is.na(output)] <- "N"
  output$swift_file_list <- NULL
  output$Log_Count <- ifelse(output[, 4] == "Y", 1, 0)
  output$Active <- NULL
  return(output)
}

.read_ranger_logs <- function(ranger_file_list, log_path, monitoring_start, monitoring_end) {
  message("Ranger log files found. Reading files:")
  output <- as.data.frame(ranger_file_list)
  output$Date <- strptime(
    sub("-\\d+\\-", "-", basename(output$ranger_file_list)),
    "ranger-%Y-%m-%d"
  )
  output$Location <- sapply(strsplit(output$ranger_file_list, "/"), function(x) x[length(x) - 1])
  output$Log_Count <- NA
  output$Active <- NA
  row_iterator <- 1
  # ignore headers in csv - log files have list at the top
  # there are 4 columns
  # adjusted pattern matching for Ranger
  for (file in output$ranger_file_list) {
    file_data <- read.csv(file)
    mic_fails <- length(grep(
      "Status: Check mic",
      file_data[, 4]
    ))
    files <- length(grep("File:", file_data[, 4]))
    recording <- any(grepl(
      "Status: ALL CLEAR - ready to record",
      file_data[, 4]
    ))
    if (mic_fails > 1 && files < 10) {
      output[row_iterator, 5] <- "N"
    } else if (mic_fails > 1 || isFALSE(recording)) {
      output[row_iterator, 5] <- "N"
    } else {
      output[row_iterator, 5] <- "Y"
    }
    row_iterator <- row_iterator + 1
  }
  output$Date <- as.Date(output$Date)
  output[is.na(output)] <- "N"
  output$ranger_file_list <- NULL
  output$Log_Count <- ifelse(output[, 4] == "Y", 1, 0)
  output$Active <- NULL
  return(output)
}







.gap_generator <- function(active_dates, monitoring_start, monitoring_end) {
  monitoring_start <- if (is.null(monitoring_start)) {
    monitoring_start <- min(unique(active_dates$Date))
  }
  monitoring_end <- if (is.null(monitoring_end)) {
    monitoring_end <- max(unique(active_dates$Date))
  }

  sites <- as.data.frame(unique(active_dates$Location))
  colnames(sites) <- c("Location")
  date_range <- as.data.frame(rep(seq(as.Date(monitoring_start), as.Date(monitoring_end), by = 1),
    each = length(sites$Location)
  ))
  colnames(date_range) <- c("Date")
  sites <- do.call("rbind", replicate(length(unique(date_range$Date)), sites, simplify = FALSE))
  date_range <- cbind(date_range, sites)
  # output$Date <- as.Date(output$Date)
  active_dates <- merge(date_range, active_dates, all.x = TRUE)
  active_dates$Log_Count[is.na(active_dates$Log_Count)] <- 0
}
